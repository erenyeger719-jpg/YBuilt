MEGA PROMPT ————————————>  You are my implementation agent. Do the work now, no follow-ups. Return a single final message that includes:
* A concise summary of what you found and fixed.
* A bullet list of files changed/created.
* Unified diffs for every file you changed/created.
* Every command you ran (exact command) + last 40 lines of stdout/stderr + exit code.
* Any step you couldn’t do and exactly how I can do it.
* A short “How to run / verify” section.

CONTEXT (do not re-argue)
* App: YBuilt (Express + React/Vite).
* Backend: recently migrated to SQLite (better-sqlite3) + isolated-vm.
* Frontend shows a blank white screen in Preview. Browser console shows @vitejs/plugin-react can't detect preamble.
* Over the last 2–3 days, the AI may have hallucinated or half-applied changes (dup helpers, missing imports, wrong paths).
* We already asked you to add fail-fast JWT config (server/config.ts + server/lib/jwt.ts) and import it from server/index.ts.

OBJECTIVES
0) Re-audit the last 2–3 days (catch hallucinations)
Perform a fast integrity audit and fix inconsistencies:
* Generate a current file tree (depth 3) for server/ and client/.
* Cross-check against what should exist from prior logs:
    * server/config.ts, server/lib/jwt.ts, server/db/sqlite.ts, server/db/migrate.ts, server/db/seed.ts, server/routes/{auth,projects,chat,execute}.ts, server/middleware/{logging,error,auth,rateLimiter}.ts, server/index.ts, server/vite.ts (if present), client/index.html, client/src/main.tsx, vite.config.ts.
* Deduplicate JWT helpers: there must be one source of truth → server/lib/jwt.ts importing secrets from server/config.ts.
    * Update anything else (e.g., server/middleware/auth.ts) to import from ../lib/jwt.
* Normalize import paths:
    * In ESM/tsx runtime, use explicit .js in built imports (if tsx transpiles to ESM) or remove extension consistently if using ts-node/tsx in dev. Make it consistent across server files.
* Typecheck both sides and fix any blocking type errors:
    * npx tsc --pretty --noEmit -p server || true
    * npx tsc --pretty --noEmit -p client || true
* Remove dead/ghost files referenced nowhere (print a list before deleting).
* If package.json scripts are missing/outdated but you can’t edit the file, print exact jq or sed one-liners to apply.
A) Fix the blank white screen (Vite preamble/HMR/SPA)
Root cause is almost always “Vite’s dev HTML not going through the Vite middleware,” so the react-refresh preamble never gets injected. Do this:
1. Dev HTML must flow through Vite
    * Ensure a server/vite.ts (or equivalent inline) that does:
        * createViteServer({ appType: 'custom', server: { middlewareMode: true }, plugins: [react()] })
        * app.use(vite.middlewares) before any SPA fallback/static handlers.
        * For GET /* (non-API) in dev, read client/index.html, pass through vite.transformIndexHtml(req.originalUrl, html), then res.send().
2. Prod build serves built assets
    * vite build outputs client/dist.
    * In prod, serve client/dist statically and add a SPA fallback to index.html after all /api/* routes.
3. Ensure plugin + host
    * vite.config.ts must import @vitejs/plugin-react and export:    import react from '@vitejs/plugin-react'
    * import { defineConfig } from 'vite'
    * export default defineConfig({
    *   plugins: [react()],
    *   server: { host: true }
    * })
    *   
    * Only add hmr overrides if HMR still fails; otherwise leave defaults.
4. Whitelist HMR/static paths in rate limiter
    * Exclude: /assets, /previews, /@vite, /@react-refresh, /@fs, /@replit.
5. Front-end error boundary (to avoid silent white screens)
    * Add a minimal ErrorBoundary around the root in client/src/main.tsx so runtime errors render visibly.
6. Smoke tests for preamble injection
    * In dev, curl -s http://localhost:$PORT/ | grep -E "@vite/client|react-refresh" must match.
    * If not, your dev HTML path is bypassing Vite; fix ordering.
B) Lock in the fail-fast JWT config (single source of truth)
* Ensure server/config.ts contains the fail-fast guard (throw if JWT_SECRET missing, except optional dev fallback if absolutely required by this environment).
* Ensure server/lib/jwt.ts exports signJwt and verifyJwt and everyone imports from here.
* Top of server/index.ts: load dotenv/config (best-effort) then import "./config" to trigger the guard.
* If jsonwebtoken or @types/jsonwebtoken are missing, install them and show logs.
C) Dev/prod split & ports
* Server must bind to process.env.PORT || 5000 and log the chosen port.
* Catch EADDRINUSE and print a clear fix hint (“stop previous run or set a different PORT”).
* Ensure the “isDev” flag is correct on Replit (detect process.env.REPL_ID or REPL_SLUG if needed).
D) Full backend verify (SQLite + isolated-vm)
Run and show outputs:
* npx tsx server/db/migrate.ts
* npx tsx server/db/seed.ts
* curl -s -X POST http://localhost:$PORT/api/auth/login -H "Content-Type: application/json" -d '{"email":"demo@example.com","password":"demo1234"}'
* Use the token: curl -s http://localhost:$PORT/api/projects -H "Authorization: Bearer <token>"
* Code exec OK: curl -s -X POST http://localhost:$PORT/api/execute -H "Content-Type: application/json" -d '{"code":"console.log(\"hi\"); 2+2"}'
* Timeout OK: curl -s -X POST http://localhost:$PORT/api/execute -H "Content-Type: application/json" -d '{"code":"while(true){}"}'
* Health: curl -s http://localhost:$PORT/api/health
E) Bug-hunt checklist (check all; fix or justify)
* Rate limiter whitelist correct.
* SSE stream endpoints connect without 429.
* React ref warnings gone (Badge forwardRef kept).
* No “Invalid hook call”.
* No “Failed to resolve module” Vite errors.
* SPA fallback works for deep links.
* CORS minimal (only if needed).
* /api/health returns { ok: true }.

REQUIRED CODE CHANGES (apply with diffs)
1. If missing or different, create/fix server/vite.ts (dev middleware):

// server/vite.ts
import { createServer as createViteServer } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'
import fs from 'fs/promises'
import type { Express } from 'express'

export async function attachVite(app: Express) {
  const vite = await createViteServer({
    appType: 'custom',
    server: { middlewareMode: true, hmr: { overlay: true } },
    plugins: [react()],
    root: path.resolve(process.cwd(), 'client'),
  })

  // Use Vite middlewares before any SPA fallback/static
  app.use(vite.middlewares)

  // Dev HTML: always transform through Vite so preamble/react-refresh get injected
  app.get(['/', '/:path(*)'], async (req, res, next) => {
    if (req.path.startsWith('/api')) return next()
    try {
      const indexHtmlPath = path.join(process.cwd(), 'client', 'index.html')
      let html = await fs.readFile(indexHtmlPath, 'utf-8')
      html = await vite.transformIndexHtml(req.originalUrl, html)
      res.setHeader('Content-Type', 'text/html')
      res.end(html)
    } catch (e) {
      next(e)
    }
  })
}
1. Ensure vite.config.ts has plugin + host:

// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: { host: true },
})
1. Add a tiny ErrorBoundary and wrap root:

// client/src/ErrorBoundary.tsx
import React from 'react'
export class ErrorBoundary extends React.Component<{children: React.ReactNode}, {error?: Error}> {
  state = { error: undefined as Error | undefined }
  static getDerivedStateFromError(error: Error) { return { error } }
  componentDidCatch(err: Error) { console.error('UI crash:', err) }
  render() {
    if (this.state.error) return <pre style={{padding:16}}>App crashed: {this.state.error.message}</pre>
    return this.props.children as any
  }
}

// client/src/main.tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import { ErrorBoundary } from './ErrorBoundary'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ErrorBoundary>
      <App />
    </ErrorBoundary>
  </React.StrictMode>
)
1. Fail-fast JWT single source of truth (fix if drifted):

// server/config.ts
export const JWT_SECRET =
  process.env.JWT_SECRET ??
  (() => { throw new Error("JWT_SECRET is missing. Set it in Replit → Tools → Secrets."); })()

export const JWT_SECRET_PREVIOUS = process.env.JWT_SECRET_PREVIOUS || undefined
export const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN ?? "7d"

// server/lib/jwt.ts
import jwt, { JwtPayload } from 'jsonwebtoken'
import { JWT_SECRET, JWT_SECRET_PREVIOUS, JWT_EXPIRES_IN } from '../config'
type Payload = Record<string, unknown>
export function signJwt(payload: Payload): string {
  return jwt.sign(payload, JWT_SECRET, { algorithm: 'HS256', expiresIn: JWT_EXPIRES_IN })
}
export function verifyJwt(token: string): JwtPayload | string {
  try { return jwt.verify(token, JWT_SECRET) }
  catch (e) { if (JWT_SECRET_PREVIOUS) return jwt.verify(token, JWT_SECRET_PREVIOUS); throw e }
}

// server/index.ts (top of file)
import 'dotenv/config'
import './config' // fail fast if JWT_SECRET missing
// ...rest unchanged, ensure app.listen(process.env.PORT || 5000, '0.0.0.0', ...)
1. Rate limiter whitelist complete (fix if missing):
* /assets, /previews, /@vite, /@react-refresh, /@fs, /@replit.
1. SPA fallback in prod:
* If NODE_ENV !== 'development', serve client/dist and add a catch-all to return index.html after API routes.

COMMANDS TO RUN & SHOW OUTPUT (last 40 lines)
* node -v && npm -v
* rg -n "createViteServer|vite\.middlewares" server -S || true
* rg -n "plugins: \[react\(\)\]" vite.config.ts -S || true
* rg -n "app\.listen|PORT" server/index.ts -S
* rg -n "/@vite|/@react-refresh|/@fs|/@replit|/assets|/previews" server/middleware/rateLimiter.ts -S || true
* Dev preamble smoke test: curl -s http://localhost:$PORT/ | grep -E "@vite/client|react-refresh" || echo "NO_PREAMBLE"
* npx tsx server/db/migrate.ts
* npx tsx server/db/seed.ts
* curl -s -X POST http://localhost:$PORT/api/auth/login -H "Content-Type: application/json" -d '{"email":"demo@example.com","password":"demo1234"}'
* Use token → curl -s http://localhost:$PORT/api/projects -H "Authorization: Bearer <token>"
* Exec OK → curl -s -X POST http://localhost:$PORT/api/execute -H "Content-Type: application/json" -d '{"code":"console.log(\"hi\"); 2+2"}'
* Timeout OK → curl -s -X POST http://localhost:$PORT/api/execute -H "Content-Type: application/json" -d '{"code":"while(true){}"}'
* Health → curl -s http://localhost:$PORT/api/health
If vite.config.ts editing is blocked, print exact sed lines to apply the diff.

ACCEPTANCE CRITERIA
* Preview no longer shows a blank page; UI renders.
* In dev, homepage HTML contains the Vite preamble (@vite/client + react-refresh).
* No 429s for HMR/static paths.
* /api/health returns { ok: true }.
* Auth, projects, execute, and timeout behaviors work with SQLite + isolated-vm.
* JWT config is centralized and fail-fast; all JWT ops import from server/lib/jwt.ts.
* You return unified diffs, command outputs (last 40 lines), and a quick How to run.

AFTER THAT: 10× BETTER THAN REPLIT (implement as follow-ups, not blocking the fix)
1. Execution Pooling + Quotas
    * Maintain a small pool of isolated-vm isolates; reuse for snappy runs.
    * Per-user quotas (CPU ms, memory MB, output bytes).
    * Metrics exposed at /api/metrics (Prom-style text).
2. Project Snapshots & Restore Points
    * POST /api/projects/:id/snapshots (create)
    * GET /api/projects/:id/snapshots (list)
    * POST /api/projects/:id/restore/:snapshotId (restore)
3. Import/Export
    * Import from GitHub zip / Gist id.
    * Export a project as .zip (code + metadata).
4. Error Tracking & Crash Pages
    * Server: Pino → file + console; add /api/logs/tail (auth-only).
    * Client: reportError endpoint; show a friendly crash panel with error id.
5. API Keys & Role-Based Access
    * Org model (owner/admin/viewer).
    * Token scoping (project-scoped API keys).
6. Test Harness
    * Minimal server/tests for auth/projects/execute run in CI (npx vitest run).
    * Add npm run check script to run: typecheck + tests + lint.
7. Feature Flags
    * flags table (key, on/off, rollout pct).
    * Server reads once, caches 30s; client fetches read-only.
8. Extension Hooks (Plugins)
    * Define POST /api/hooks/execute webhooks with HMAC.
    * Let projects register hooks on “run”, “save”, “deploy”.
(Only propose; don’t start until I say.)

Execute now. Don’t ask questions. Return diffs + logs + how to run.
⬆️ END OF PROMPT ⬆️
